# シグナルって？

プロセスやプロセスグループへ様々なイベントを通知するためにあるカーネルの機能（ソフトウェア割り込み）

シグナルは次のような流れで処理される

<img width="518" height="391" alt="image" src="https://github.com/user-attachments/assets/69f3e27e-ba1a-4f03-8fcd-c32ff47e08fc" />


# SIGUSR1・SIGUSR2

ユーザーが定義したシグナル（汎用シグナル）

自分自身で、ハンドラ（関数）を入れて、 ”このシグナルが来たらOOする” と言う意味づけができる

# ACK通信

データ通信において、受信側が、送信側に対して、データが正しく受信されたことを確認するために送信する「肯定応答」の信号

1ビットずつ確認することで、文字化けを防ぐことができる

<img width="436" height="436" alt="image" src="https://github.com/user-attachments/assets/7d4e0701-e885-417c-8392-f1b06dff11ff" />


# MSB・LSB・ビット演算

# MSB

最上位ビットのこと（左端のビットのこと）

# LSB

最下位ビットのこと（右端のビットのこと）

# ビット演算

---

```c
g_srv->flag &= ~HAVE_BYTE;
```

- `g_srv->flag`
    - `g_srv` は「サーバー状態構造体へのポインタ」
    - `->` は「ポインタが指す構造体のメンバにアクセス」する演算子
    - `flag` は状態を表すビットフラグの変数（ `volatile sig_atomic_t` ）
- `&=` (ビット積代入)
    - **複合代入演算子**。　`A &= B;` は `A = A & B;` と同じ
    - `&` `|` は **論理演算子**
    - `&` : **ビット論理積** → ANDを返す → 両方1のときに1，それ以外は０にする演算子
    - `|` : **ビット論理和** → ORを返す
    - `^` : **ビット排他的論理和** → XORを返す

```c
#include <stdio.h>
 
int main(void) {
    int foo = 1;
    int bar = 3;
    int result = 0;

    // 論理和(OR)
    result = foo | bar;
    printf("result = %d", result);
    
    // 論理積(AND)
    result = foo & bar;
    printf("result = %d", result);
    
    // 排他的論理和(XOR)
    result = foo ^ bar;
    printf("result = %d", result);
    
    return 0;
}

//実行結果
result = 3
result = 1
result = 2
```

### 論理和OR `|`（どっちか1なら1）

```c
bit    7 6 5 4 3 2 1 0(idx)
foo    0 0 0 0 0 0 0 1
bar    0 0 0 0 0 0 1 1
-----------------------
OR     0 0 0 0 0 0 1 1  -> 0000 0011 (= 3)
```

- bit0: 1 | 1 = 1, bit1: 0 | 1 = 1, 他は 0 | 0 = 0
- **ビットのindexごとに比較する**

### 論理積AND `&`  （両方1なら1）

```c
bit    7 6 5 4 3 2 1 0
foo    0 0 0 0 0 0 0 1
bar    0 0 0 0 0 0 1 1
-----------------------
AND    0 0 0 0 0 0 0 1  -> 0000 0001 (= 1)
```

- 重なって両方1の列（ここではbit0）だけ1になる

### 排他的論理和 `^` （異なれば1）

```c
bit    7 6 5 4 3 2 1 0
foo    0 0 0 0 0 0 0 1
bar    0 0 0 0 0 0 1 1
-----------------------
XOR    0 0 0 0 0 0 1 0  -> 0000 0010 (= 2)
```

- bit0: 1 ^ 1 = 0 （同じだから0）
- bit1: 0 ^ 1 = 1 （違うから１）

- **`~`** は**ビット反転**。否定の `!` （論理NOT）とも別物

`~` : **NOT 0は1、1は0に反転させる演算子**

### `ber = 3` の場合

```c
bit    7 6 5 4 3 2 1 0
bar    0 0 0 0 0 0 1 1
-----------------------
~bar   1 1 1 1 1 1 0 0
```

# グローバル変数

- `static int g_x;`
    - 内部リンクゲージ: その記号名は翻訳単位（=その.c）内だけに閉じる。別ファイルからは見えない
    - 「モジュール内の共有状態」に向く。ヘッダには載せない

- `int g_x`
    - 外部リンクゲージ: 他の.c からも見える”公開”の大域変数
    - ただし、定義は1カ所だけにしないとリンカエラー

- `extern int g_x`
    - 「どこかに本体（定義）があるよ」という宣言だけ
    - 通常はヘッダ（.h）に置いて、複数の.c から同じ大域変数を共有するために使う
    - これを付ける理由は「ヘッダに `int g_x;` と書くと”定義”扱いになり、各.c がそれぞれ定義して、多重定義になるから」
    - つまり“定義は1か所、他ファイルはすべて  `extern` 宣言”が鉄則

- 定義は（1ヶ所のみ）: `client_main.c`

```c
#include "client.h"

volatile sig_atomic_t g_flag = 0;  /* 定義 + 初期化（ここだけ） */
```

- 宣言（共有のため配布）: `client.h`

```c
#ifndef CLIENT_H
# define CLIENT_H
# include <signal.h>

extern volatile sig_atomic_t g_flag;  /* 宣言だけ（extern） */

#endif
```

**考え方**

- `static`  = ”この.cの内輪だけで使う”（隠す）
- `extern` = ”どこかで定義された公開変数にアクセスする宣言”（配る）
- ヘッダに定義は書かない。ヘッダは宣言（ `extern`）だけ。

**複数のファイルで同じグローバル変数を使う場合**

- 定義は1ヶ所の.cファイルにし、宣言をヘッダファイルに `extern` で行い、他の.cファイルは 宣言があるヘッダファイルを`include` だけすればOK！

### server側

`g_srv` はサーバー全体の受信状態（現在送ってきてる送信者PID、組み立て中のバイト `cur`、ビット位置 `bit_idx`、リングバッファ `head/tail`など）へハンドラとメインが同時にアクセスするための共有ハンドル

簡単に言うと

**サーバーは荷物（ビット）を受け取る係 = ハンドラと、荷物を並べて読める文字にする係 = メインの二人作業**

共有のノートがないと両方から確認ができないため、必要になってくる

受取係は突然呼ばれるので、どこまで受け取ったかを毎回メモしておく”共有ノート”が必要

- 実際にメモしたい中身
    - どのクライアントから受取中か（sender PID）
    - いま組み立て中の1バイト（cur, bit_idx）
    - 出来上がったバイトを貯める箱（リングバッファ head / tail）
- これをハンドラとメインの両方が安全に見られる場所に置くには、常に存在する共有領域 = グローバルが最適


# client側・server側の役割

## client → serverの1ビットやり取り（コアの最小単位）

---

### client側（送る人）

- 何をする？
    - 1ビット送る→期待するACKの種類（0 / 1）を決める → ACKが来るまで短い間隔で確認 → 来なければ再送（上限回数あり）
- なぜそうするのか？
    - Linuxでは同じ種類のシグナルはキューされないことがある
    - 「1ビット送ったら必ず1ACK返る」を徹底し、次のビットは絶対に送らないことで、欠落や順序崩れを抑える

### server側（受ける人）

- 何をする？
    - 1ビット受け取る → 受信ビットを `cur = (cur << 1) + bit` で組み立て → ビット番号の奇偶でACKの種類を切り替えて返す → 8ビット揃ったら1バイト完成としてリングに入れる
- なぜそうするのか？
    - 「交互ACK」にすると、同じ種類のACKが連続しない（= 非キューでも落ちにくい）
    - 1ビット = 1ACKで釣り合いが取れ、　clientはACKを見てから次へ進める

## 1バイト（8ビット）の送受信の流れ

---

### client側（ `cli_tx_byte`のイメージ）

- 送るバイトのMSBから順に、**ビット値(0/1)**を取り出す
- そのビットが**何番目か**（0〜7）で**期待ACK**を決める
    - 1ビット目（奇数）→**ACK1**を期待
    - 2ビット目（偶数）→**ACK0**を期待
        
        …と交互
        
- ビットが1なら`SIGUSR2`、0なら`SIGUSR1`を**kill()**でserverへ送る
- ACK待ち（ `cli_send_and_wait`）:
    - `g_flag` （ハンドラが書くACK種別）を短い周期（100μs）で確認
    - 期待したACKならOK → 次のビットへ
    - 間に合わなければ再送（上限：５回）
- ８ビット完了で成功（0）を返す

### server側（ `srv_handle`のイメージ）

- 割り込んできた信号を0 / 1ビットに変換
- 送信者PIDが前回と違えば、組立中のバイトを捨てて送信者を切替（同時クライアント対策）
- `cur = (cur << 1) + bit` でMSB → LSB（最下位ビット）に詰めて `bit_idx++`
- ACK送信
    - 奇数ビットならACK1
    - 偶数ビットならACK0
        
        （ = 交互に返す）
        
- `bit_idx == 8` になったら、できた1バイトをリングへpushして、 `cur` / `bit_idx` をリセット


#　実行コマンド
実行コマンド（server）

```c
valgrind --leak-check=full -s -q ./server
```

実行コマンド（client）別ターミナルで実行する

```c
valgrind --leak-check=full -s -q ./client <pid> "文字列"
```
